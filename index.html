<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Animations</title>

    <script src="https://pixijs.download/release/pixi.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js
"></script>
  </head>

  <body>
    <script>
      // The app
      const app = new PIXI.Application({
        width: 1024,
        height: 768,
        backgroundColor: 0x000000,
      });

      // class Counter {
      //   // For generating unique counters so all of the objects start at different spots on the sine wave
      //   constructor() {
      //     this.value = Math.floor(Math.random() * 1000);
      //   }
      // }

      document.body.appendChild(app.view);

      // Animator
      const Animate = {};

      Animate.to = function (obj, end) {
        // Make a promise
        return new Promise((resolve, reject) => {
          // Initial state parameters
          const start = {
            x: obj.x,
            y: obj.y,
            scaleX: obj.scale.x,
            scaleY: obj.scale.y,
            alpha: obj.alpha,
            rotation: (obj.rotation * 180) / Math.PI,
            tint: obj.tint,
            skewX: obj.skewX,
            skewY: obj.skewY
          };

          // Set defaults
          if (end.duration == undefined) end.duration = 100;
          if (end.easing == undefined) end.easing = Animate.linear;

          // We need to know when we start
          const startTime = Date.now();

          //This is the object's animation loop
          function loop() {
            // Calculate delta
            const ticker = Date.now() - startTime;
            const delta = ticker / end.duration;
            const ease = end.easing(delta);

            // Are we done? Snap to end
            if (delta >= 1 || end.duration === 0) {
              if (end.x != undefined) {
                obj.x = end.x;
              }
              if (end.y != undefined) {
                obj.y = end.y;
              }
              if (end.scaleX != undefined) {
                obj.scale.x = end.scaleX;
              }

              if (end.scaleY != undefined) {
                obj.scale.y = end.scaleY;
              }

              resolve();
              return;
            }

            function lerp(a, b, n) {
              return (1 - n) * a + n * b;
            }

            // Lerp alpha
            if (end.alpha != undefined) {
              obj.alpha = lerp(start.alpha, end.alpha, ease);
            }
            // lerp coordinates
            if (end.x != undefined) {
              obj.x = lerp(start.x, end.x, ease);
            }
            if (end.y != undefined) {
              obj.y = lerp(start.y, end.y, ease);
            }

            // Lerp scale
            if (end.scaleX != undefined) {
              obj.scale.x = lerp(start.scaleX, end.scaleX, ease);
            }
            if (end.scaleY != undefined) {
              obj.scale.y = lerp(start.scaleY, end.scaleY, ease);
            }

            // Lerp rotation
            // this reminded me that 0 is falsy
            if (end.rotation != undefined) {
              obj.rotation = lerp(
                // Converting these to degrees because it's easier to visualize
                (start.rotation * Math.PI) / 180,
                (end.rotation * Math.PI) / 180,
                ease
              );
            }

            // Lerp tint
            if (end.tint != undefined) {
              obj.tint = lerp(start.tint, end.tint, ease);
            }

            if (end.skewX != undefined) {
              obj.skew.x = lerp(start.skewX, end.skewX, ease);
            }
            if (end.skewY != undefined) {
              obj.skew.y = lerp(start.skewY, end.skewY, ease);
            }
            // Loop
            // Saving the animationID for later
            obj.animationID = requestAnimationFrame(loop);
          }
          cancelAnimationFrame(obj.animationID);
          loop();
        });
      };

      Animate.stop = function (obj) {
        cancelAnimationFrame(obj.animationID);
      };

      Animate.linear = (x) => x;

      // Quadratic Easing
      Animate.easeIn = (x) => x * x;

      Animate.easeOut = (x) => 1 - (1 - x) * (1 - x);

      Animate.easeInOut = (x) => {
        if (x < 0.5) return 2 * x * x;
        return 1 - Math.pow(-2 * x + 2, 2) / 2;
      };

      Animate.easeInCubic = (x) => {
        return x * x * x;
      };
      // Pause
      Animate.pause = (ms) => {
        return new Promise((resolve, reject) => setTimeout(resolve, ms));
      };

      // Instantiate the fish
      const fish1 = PIXI.Sprite.from("img/fish1.png");
      const fish2 = PIXI.Sprite.from("img/fish2.png");
      const fish3 = PIXI.Sprite.from("img/fish3.png");

      // Fish1
      fish1.anchor.set(0.5);
      fish1.scale.set(0.1);
      fish1.startOrientation = fish1.scale.x;
      fish1.interactive = true;
      //storing initial positions in properties for later reference

      fish1.x = 900;
      fish1.y = 200;
      fish1.startX = fish1.x;
      fish1.startY = fish1.y;

      // Fish2
      fish2.x = 400;
      fish2.y = 400;

      fish2.startOrientation = fish2.scale.x;

      // Fish3
      fish3.anchor.set(0.5);
      fish3.scale.set(0.2);
      fish3.scale.x *= -1;
      fish3.startOrientation = fish3.scale.x;
      fish3.interactive = true;

      fish3.x = 200;
      fish3.y = 600;
      fish3.startX = fish3.x;
      fish3.startY = fish3.y;

      // Add school of fish
      const school = new PIXI.Container();
      school.addChild(PIXI.Sprite.from('img/fish2.png'));
      school.addChild(PIXI.Sprite.from('img/fish2.png'));
      school.addChild(PIXI.Sprite.from('img/fish2.png'));
      school.children.forEach(fish => {
        fish.anchor.set(0.5);
        fish.scale.set(0.1);
        fish.scale.x *= -1;
      });
      school.children[1].x = 75;
      school.children[1].y = 75;
      school.children[2].y = 150;
      school.x = 100;
      school.y = 200;
      // Add bubbler
      // const bubbler = new Bubbler();
      const bubblePool = new PIXI.Container();
      bubblePool.x = 50;
      bubblePool.y = 800;
      const bubbleNoise = new PIXI.NoiseFilter(.8, 3);
      for (let i = 0; i < 50; i++) {
        const bubble = new PIXI.Graphics();
        bubble.filters = [bubbleNoise];
        bubble.x = Math.floor(Math.random() * 200);
        const radius = Math.floor(Math.random() * 15) + 15;
        bubble.buoyancy = radius / 7;
        bubble.beginFill(0xDD3366);
        bubble.drawCircle(0, 0, radius + 1);
        bubble.beginFill(0xCCAAff);
        bubble.drawCircle(0, 0, radius);
        bubble.beginFill(0xEEeeff);
        bubble.alpha = 0.2;
        bubble.drawCircle(2, -2, radius - 3);
        bubble.endFill();
        bubblePool.addChild(bubble);
      }

      //Add a background with filter
      const background = new PIXI.Graphics();
      const backgroundNoise = new PIXI.NoiseFilter(4, 300);
      background.beginFill(0x000000);
      // background.alpha = ;
      background.drawRect(0, 0, app.renderer.width, app.renderer.height);
      background.alpha = .1;
      background.filters = [backgroundNoise];
      // Add a fully transparent "glass" layer behind the fish to tap on and attract fish3
      const glass = new PIXI.Graphics();
      glass.interactive = true;
      glass.beginFill(0x000000);
      glass.alpha = 0;

      glass.drawRect(0, 0, app.renderer.width, app.renderer.height);

      // Add some abstract sand
      const sand = new PIXI.Graphics();
      const sandNoise = new PIXI.NoiseFilter(0.4, 6);
      sand.beginFill(0x99CCFF);
      sand.drawRect(
        0,
        app.renderer.height - 80,
        app.renderer.width,
        app.renderer.height
      );
      sand.filters = [sandNoise];

      // Add plant
      const plant = PIXI.Sprite.from('img/plant.png');
      const plantNoise = new PIXI.NoiseFilter(.8, 1000);

      plant.anchor.set(1);
      plant.tint = 0x00FFAA;
      plant.alpha = .6;
      plant.scale.y = 1.4;
      plant.x = 1000;
      plant.y = 750;
      plant.filters = [plantNoise];
      // plant.skew.x = .2;

      // Add rocks
      const rocks = new PIXI.Container();
      const rock1 = PIXI.Sprite.from("img/rock.png");
      const rock2 = PIXI.Sprite.from("img/rock.png");
      const rock3 = PIXI.Sprite.from("img/rock.png");
      rocks.addChild(rock1);
      rocks.addChild(rock2);
      rocks.addChild(rock3);
      rock1.anchor.set(0.5);
      rock2.anchor.set(0.5);
      rock3.anchor.set(0.5);
      rock1.scale.set(0.5);
      rock1.tint = 0xaaaaaa;
      rock2.scale.set(0.4);
      rock2.tint = 0xcccccc;
      rock3.scale.set(0.3);
      rock3.tint = 0xeeeeee;

      rock2.x = -60;
      rock2.y = 26;

      rock3.x = 88;
      rock3.y = 35;

      rocks.x = 130;
      rocks.y = 700;
      rocks.scale.set(1.3);

      //Add all objects to the stage
      app.stage.addChild(background);
      app.stage.addChild(sand);

      app.stage.addChild(fish3);
      app.stage.addChild(bubblePool);

      app.stage.addChild(rocks);
      app.stage.addChild(plant);
      app.stage.addChild(glass);
      app.stage.addChild(fish1);
      app.stage.addChild(school);

      // Define fish behaviors

      async function fish1Behavior() {
        await Animate.to(fish1, {
          y: fish1.y + 50,
          duration: 1000,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish1, {
          y: fish1.y - 50,
          duration: 1000,
          easing: Animate.easeIn,
        });

        requestAnimationFrame(fish1Behavior);
      }

      async function schoolBehavior() {
        await Animate.to(school, {
          x: 800,
          y: 350,
          duration: Math.random() * 1500 + 1500,
          easing: Animate.easeInOut
        });
        await Animate.to(school, {
          scaleX: school.scale.x * -1,
          duration: 250,
          easing: Animate.easeInOut
        });

        await Animate.to(school, {
          x: 100,
          y: 400,
          duration: Math.random() * 1500 + 1500,
          easing: Animate.easeInOut
        });
        await Animate.to(school, {
          scaleX: school.scale.x * -1,
          duration: 250,
          easing: Animate.easeInOut
        });
        await Animate.to(school, {
          x: 100,
          y: 100,
          duration: Math.random() * 1500 + 1500,
          easing: Animate.easeInOut
        });
        requestAnimationFrame(schoolBehavior);
      }


      function schoolChildrenBehavior() {
        const behaviors = school.children.map(fish => {
          return async function () {
            await Animate.to(fish, {
              y: fish.y + 25,
              duration: Math.random() * 500 + 250,
              easing: Animate.easeInOut,
            });
            await Animate.to(fish, {
              y: fish.y - 25,
              duration: Math.random() * 500 + 250,
              easing: Animate.easeInOut,
            });
            // I didn't even know arguments.callee existed before this
            requestAnimationFrame(arguments.callee);
          };
        });

        behaviors.forEach(fun => fun());
      }

      async function fish3Behavior() {
        await Animate.to(fish3, {
          x: fish3.x + 600,
          duration: 1500,
          easing: Animate.easeOut,
        });
        await Animate.to(fish3, {
          scaleX: fish3.scale.x * -1,
          duration: 250,
          easing: Animate.easeIn,
        });
        await Animate.to(fish3, {
          x: fish3.x - 600,
          duration: 1500,
          easing: Animate.easeOut,
        });
        await Animate.to(fish3, {
          scaleX: fish3.scale.x * -1,
          duration: 250,
          easing: Animate.easeIn,
        });


        requestAnimationFrame(fish3Behavior);
      }

      async function plantBehavior() {
        await Animate.to(plant, {
          skewX: -.2,
          duration: 750,
          easing: Animate.easeInOut
        });
        await Animate.to(plant, {
          skewX: .2,
          duration: 750,
          easing: Animate.easeInOut
        });
      }



      function bubbler() {
        const bubbleBehaviors = bubblePool.children.map(bubble => {
          return async function () {
            await Animate.to(bubble, {
              y: -app.screen.height - 100,
              duration: 12000 / bubble.buoyancy,
              easing: Animate.easeIn
            });
            bubble.y = Math.floor(Math.random() * 75);
            bubble.x = Math.floor(Math.random() * 200);

            // I didn't even know arguments.callee existed before this
            requestAnimationFrame(arguments.callee);
          };
        });

        bubbleBehaviors.forEach(fun => fun());
      }
      // Interactive events in order of precedence
      glass.on("pointertap", async (event) => {
        const origX = fish3.x;
        const origY = fish3.y;
        const tapX = event.screen.x;
        const tapY = event.screen.y;
        const currentFish3Orientation = Math.abs(fish3.scale.x) / fish3.scale.x;
        glass.interactive = false;
        //Handling fish orientation
        if (tapX > origX) {
          await Animate.to(fish3, {
            scaleX: Math.abs(fish3.scale.x) * -1,
            duration: 250,
            easing: Animate.easeOut,
          });
        } else if (tapX < origX) {
          await Animate.to(fish3, {
            scaleX: Math.abs(fish3.scale.x),
            duration: 250,
            easing: Animate.easeInOut,
          });
        }

        //Swim to where user tapped glass
        await Animate.to(fish3, {
          x: tapX,
          y: tapY,
          duration: 2000,
          easing: Animate.easeOut,
        });


        // Do a little angry dance
        await Animate.to(fish3, {
          tint: 0xff0000,
          rotation: 45,
          duration: 250,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish3, {
          tint: 0xffffff,
          rotation: -45,
          duration: 250,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish3, {
          tint: 0xff0000,
          rotation: 45,
          duration: 250,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish3, {
          tint: 0xffffff,
          rotation: -45,
          duration: 250,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish3, {
          tint: 0xffffff,
          rotation: 0,
          duration: 250,
          easing: Animate.easeInOut,
        });
        await Animate.pause(500);

        //Handling fish orientation
        if (tapX > fish3.startX) {
          await Animate.to(fish3, {
            scaleX: Math.abs(fish3.scale.x),
            duration: 250,
            easing: Animate.easeInOut,
          });
        } else if (tapX < fish3.startX) {
          await Animate.to(fish3, {
            scaleX: Math.abs(fish3.scale.x) * -1,
            duration: 250,
            easing: Animate.easeInOut,
          });
        }

        //Swim back
        await Animate.to(fish3, {
          x: fish3.startX,
          y: fish3.startY,
          duration: 2000,
          easing: Animate.easeInOut,
        });

        //Handling fish orientation
        await Animate.to(fish3, {
          scaleX: fish3.startOrientation,
          duration: 250,
          easing: Animate.easeInOut,
        });
        glass.interactive = true;
        requestAnimationFrame(fish3Behavior);
      });
      fish1.on("pointertap", async (event) => {
        fish1.interactive = false;
        await Animate.to(fish1, {
          y: 50,
          x: 350,
          duration: 2000,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish1, {
          scaleX: fish1.scale.x * -1,
          duration: 250,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish1, {
          rotation: 980,
          tint: 0x00ffff,
          duration: 1500,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish1, {
          rotation: 0,
          tint: 0xffffff,
          duration: 1500,
          easing: Animate.easeInOut,
        });
        fish1.tint = 0xffffff;
        await Animate.to(fish1, {
          y: fish1.startY,
          x: fish1.startX,
          duration: 2000,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish1, {
          scaleX: fish1.scale.x * -1,
          duration: 250,
          easing: Animate.easeInOut,
        });
        fish1.interactive = true;
        fish1Behavior();
      });

      window.addEventListener("load", fish1Behavior);
      window.addEventListener("load", fish3Behavior);
      window.addEventListener("load", bubbler);
      window.addEventListener("load", schoolBehavior);
      window.addEventListener("load", schoolChildrenBehavior);
      // window.addEventListener("load", plantBehavior);


      // Check easings.net for more easing functions
    </script>
  </body>

</html>