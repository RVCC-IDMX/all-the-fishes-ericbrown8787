<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>All the Fishes</title>
    <script src="https://pixijs.download/release/pixi.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js
"></script>
  </head>

  <body>
    <script>
      // Hint Put each fish in a container. Move fish by moving container and animate fish by selecting fish specifically.

      // The app
      const app = new PIXI.Application({
        width: 640,
        height: 480,
        backgroundColor: 0xd6f1ff,
      });

      class Counter {
        // For generating unique counters so all of the objects start at different spots on the sine wave
        constructor() {
          this.value = Math.floor(Math.random() * 1000);
        }

        increment() {
          this.value += 1;
        }
      }

      class Actor {
        // We don't really get interfaces in JS, so I'll take what I can get.
        constructor() {
          this.counter = new Counter();
        }
      }
      class Fish extends Actor {
        // Sprite should be side view drawing of fish looking to the right
        constructor(
          imagePath,
          scale,
          baseX,
          baseY,
          xVariance,
          yVariance,
          slider = null,
          draggable = false
        ) {
          super();

          this.slider = slider;
          this.sprite = PIXI.Sprite.from(imagePath);
          this.baseX = baseX;
          this.baseY = baseY;
          this.scale = Math.abs(scale); // Not allowing negative values for scale.
          this.xVariance = xVariance;
          this.yVariance = yVariance;
          this.sprite.anchor.set(0.5);
          this.sprite.scale.set(this.scale);
          this.body = new PIXI.Container();
          this.body.addChild(this.sprite);
          this.previousPos = this.body.x;

          app.stage.addChild(this.body);
        }

        tick() {
          if (!this.dragging) {
            this.wiggle(5, 220);
            if (this.slider) {
              // If a slider is assigned to this fish, allows its size to be adjusted
              this.sprite.scale.set(this.scale + slider.value * this.scale);
            }
            this.moveX(
              this.baseX + Math.sin(this.counter.value / 100) * this.xVariance
            );
            this.moveY(
              this.baseY + Math.sin(this.counter.value / 40) * this.yVariance
            );
            this.counter.increment();
          }
        }

        orientSprite() {
          if (this.body.x < this.previousPos && this.sprite.scale.x < 0) {
            this.sprite.scale.x = Math.abs(this.sprite.scale.x);
          } else if (
            this.body.x > this.previousPos &&
            this.sprite.scale.x > 0
          ) {
            this.sprite.scale.x *= -1;
          }
        }

        moveX(x) {
          this.body.x = x;
          this.orientSprite();
          this.previousPos = this.body.x;
        }

        moveY(y) {
          this.body.y = y;
        }

        wiggle(wiggleFrequency, wiggleIntensity) {
          this.sprite.scale.x =
            this.scale +
            Math.sin(this.counter.value / wiggleFrequency) / wiggleIntensity;
        }
      }
      class CamoFish extends Fish {
        constructor(imagePath, scale, baseX, baseY, xVariance, yVariance) {
          super(imagePath, scale, baseX, baseY, xVariance, yVariance);
          this.colorScale = chroma
            .scale(["green", "blue", "indigo", "violet"])
            .mode("lrgb")
            .gamma(2)
            .colors(1000)
            .map((color) => Number(`0x${color.slice(1, color.length)}`));

          this.changeRate = 200;
        }

        tick() {
          if (!this.dragging) {
            this.wiggle(5, 300);
            this.moveX(
              this.baseX + Math.sin(this.counter.value / 100) * this.xVariance
            );
            this.moveY(
              this.baseY + Math.sin(this.counter.value / 40) * this.yVariance
            );
            this.counter.increment();

            // Change colors
            this.changeColor();
          }
        }

        changeColor() {
          const colorIndex =
            (Math.sin(this.counter.value / this.changeRate) + 1) *
            (this.colorScale.length / 2);
          this.sprite.tint = this.colorScale[Math.floor(colorIndex)];
        }
      }

      class DraggableFish extends PIXI.Container {
        constructor() {
          super();
          this.counter = new Counter();
          this.baseX = 0;
          this.baseY = 0;
          // Make container interactive
          this.interactive = true;

          //Button Body
          const sprite = PIXI.Sprite.from("img/fish.png");
          sprite.scale.set(-0.15, 0.15);
          sprite.anchor.set(0.5);
          this.addChild(sprite);
          this.sprite = sprite;

          //Event listeners
          // this.on("pointertap", (e) => {
          //   console.log(e);
          //   const color = Math.random() * 0xffffff;
          //   sprite.tint = color;
          // });

          this.on("pointerover", (e) => {
            sprite.alpha = 0.7;
          });

          this.on("pointerout", (e) => {
            sprite.alpha = 1;
          });

          // Draggable event listeners
          this.draggable = true; //whether it can drag
          this.dragging = false; //whether this is currently being dragged

          // Offsets prevent button from snapping onto cursor upon dragging
          this.offsetX;
          this.offsteY;

          this.on("pointerdown", (e) => {
            if (!this.draggable) return;
            this.dragging = true;
            this.offsetX = this.x - e.global.x;
            this.offsetY = this.y - e.global.y;
          });

          this.on("pointermove", (e) => {
            if (!this.draggable) return;
            // console.log(e.global.x, e.global.y);
            if (this.dragging) {
              this.x = e.global.x + this.offsetX;
              this.y = e.global.y + this.offsetY;
              this.baseX = this.x;
              this.baseY = this.y;
            }
          });
          this.on("pointerup", (e) => {
            if (!this.draggable) return;
            this.dragging = false;
          });

          // Failsafe. Just in case pointer ends up outside of button somehow
          this.on("pointerupoutside", (e) => {
            if (!this.draggable) return;
            this.dragging = false;
          });
        }

        tick() {}
      }

      class School extends Actor {
        constructor(baseX, baseY, xVariance, yVariance) {
          super();
          this.baseX = baseX;
          this.baseY = baseY;
          this.xVariance = xVariance;
          this.yVariance = yVariance;
          this.origin = new PIXI.Container();
          this.origin.x = baseX;
          this.origin.y = baseY;
          this.previousPos = this.origin.x;
          this.fish = [
            new Fish("img/fish.png", 0.1, 0, 0, xVariance, yVariance),
            new Fish("img/fish.png", 0.1, 50, 50, xVariance, yVariance),
            new Fish("img/fish.png", 0.1, 50, -50, xVariance, yVariance),
          ];

          this.fish.forEach((fish) => {
            fish.counter = this.counter;
            this.origin.addChild(fish.body);
          });
          app.stage.addChild(this.origin);
        }

        tick() {
          this.fish.forEach((fish) => fish.tick());
          this.counter.increment();
        }
      }

      class Bubbler extends Actor {
        constructor() {
          super();
          this.origin = new PIXI.Container();
          this.maxBubbles = 10;
          this.origin.y = app.renderer.height;
          this.origin.x = 50;
          this.timer = Date.now();
          this.delay = 200;
          this.bubbleDirection = 1;

          app.stage.addChild(this.origin);
        }

        tick() {
          // Clear old bubbles
          this.origin.children.forEach((bubble) => {
            if (bubble.y < -this.origin.y) {
              bubble.destroy();
            }
          });

          //Spawn new bubbles if possible
          if (
            this.origin.children.length <= this.maxBubbles &&
            Date.now() >= this.timer + this.delay
          ) {
            this.spawnBubble();
            this.timer = Date.now() + Math.floor(Math.random() * 250);
          }
          this.moveBubbles();
          this.counter.increment();
        }

        spawnBubble() {
          const bubble = new PIXI.Graphics();
          const radius = Math.floor(Math.random() * 15) + 15;
          bubble.movementDirection = -1;
          bubble.sineMultiplier =
            this.bubbleDirection * (Math.floor(Math.random() * 50) + 20);
          bubble.buoyancy = radius / 7;
          bubble.beginFill(0x333333);
          bubble.drawCircle(0, 0, radius + 1);
          bubble.beginFill(0x77ffff);
          bubble.drawCircle(0, 0, radius);
          bubble.beginFill(0x99eeff);
          bubble.alpha = 0.2;
          bubble.drawCircle(2, -2, radius - 3);
          bubble.endFill();

          this.origin.addChild(bubble);
          const possibleDirections = [1, -1];
          this.bubbleDirection *= possibleDirections[Math.round(Math.random())];
        }

        moveBubbles() {
          this.origin.children.forEach((bubble) => {
            bubble.x =
              this.origin.x +
              Math.sin(this.counter.value / 70) * bubble.sineMultiplier;
            bubble.y -= bubble.buoyancy;
          });
        }
      }

      class Plant extends Actor {
        constructor(imagePath, scale, x, y) {
          super();
          this.sprite = PIXI.Sprite.from(imagePath);
          this.sprite.anchor.set(1);
          this.scale = scale;
          this.sprite.scale.set(scale);
          this.sprite.x = x;
          this.sprite.y = y;
          this.sprite.filters = [new PIXI.NoiseFilter(0.9, 9)];
          this.sprite.alpha = 0.8;
          this.sprite.tint = 0x999999;
          app.stage.addChild(this.sprite);
        }

        tick() {
          this.counter.increment();
        }
      }

      // Our Button
      class Button extends PIXI.Container {
        constructor(label = "Button", w = 200, h = 50) {
          super();
          this.label = label;
          this.h = h;
          this.w = w;

          // Make container interactive
          this.interactive = true;

          //Button Body
          const buttonBody = new PIXI.Graphics();
          buttonBody.beginFill(0xcccccc);
          buttonBody.drawRect(0, 0, this.w, this.h);
          buttonBody.endFill();
          this.addChild(buttonBody);
          this.buttonBody = buttonBody;

          //Button Label
          const buttonLabel = new PIXI.Text(this.label);
          buttonLabel.anchor.set(0.5);
          buttonLabel.x += buttonBody.width / 2;
          buttonLabel.y += buttonBody.height / 2;
          this.addChild(buttonLabel);
          this.buttonLabel = buttonLabel;

          // Event listeners
          // this.on("pointertap", (e) => {
          //   console.log(e);
          //   const color = Math.random() * 0xffffff;
          //   buttonBody.tint = color;
          // });

          this.on("pointerover", (e) => {
            buttonBody.alpha = 0.7;
          });

          this.on("pointerout", (e) => {
            buttonBody.alpha = 1;
          });

          // Draggable event listeners
          this.draggable = false; //whether it can drag
          this.dragging = false; //whether this is currently being dragged

          // Offsets prevent button from snapping onto cursor upon dragging
          this.offsetX;
          this.offsteY;

          this.on("pointerdown", (e) => {
            if (!this.draggable) return;
            this.dragging = true;
            this.offsetX = this.x - e.global.x;
            this.offsetY = this.y - e.global.y;
          });

          this.on("pointermove", (e) => {
            if (!this.draggable) return;
            // console.log(e.global.x, e.global.y);
            if (this.dragging) {
              this.x = e.global.x + this.offsetX;
              this.y = e.global.y + this.offsetY;
            }
          });
          this.on("pointerup", (e) => {
            if (!this.draggable) return;
            this.dragging = false;
          });

          // Failsafe. Just in case pointer ends up outside of button somehow
          this.on("pointerupoutside", (e) => {
            if (!this.draggable) return;
            this.dragging = false;
          });
        }
      }

      class Toggle extends Button {
        constructor(label, w, h) {
          super(label, w, h);
          // Extra variables
          this.value = false;
          // Event listeners
          this.on("pointertap", (e) => {
            this.value = !this.value;
            console.log(this.value);

            if (this.value == true) {
              this.buttonBody.tint = 0x00cc00;
            } else {
              this.buttonBody.tint = 0xcccc00;
            }
          });
        }
      }

      class Slider extends PIXI.Container {
        constructor() {
          super();
          this.interactive = true;
          // Extra Variables
          this.dragging = false;
          this.value = 0;

          //The Track

          const track = new PIXI.Graphics();
          track.beginFill(0xeeeeee);
          track.drawRect(0, -10, 300, 20);
          track.endFill();

          this.addChild(track);

          // The Slide
          const slide = new PIXI.Graphics();
          slide.beginFill(0xcccccc);
          slide.drawRect(-25, -25, 50, 50);
          slide.endFill();

          this.addChild(slide);

          //Events
          this.on("pointerdown", (e) => {
            this.dragging = true;
            console.log(e);
          });

          this.on("pointermove", (e) => {
            if (this.dragging) {
              // Move the slider
              slide.x = e.global.x - this.getGlobalPosition().x;
              // Check constraints
              if (slide.x > track.width) slide.x = track.width;
              if (slide.x < 0) slide.x = 0;
              // Check value
              this.value = slide.x / track.width;
            }
          });

          this.on("pointerup", (e) => {
            this.dragging = false;
          });

          this.on("pointerupoutside", (e) => {
            this.dragging = false;
          });
        }
      }

      document.body.appendChild(app.view);

      // Setting up scenery
      const backgroundMask = new PIXI.Graphics();
      backgroundMask.beginFill(0xffffff);
      backgroundMask.drawRect(0, 0, app.renderer.width, app.renderer.height);
      backgroundMask.alpha = 0.5;
      backgroundMask.filters = [
        new PIXI.NoiseFilter(0.8, 6),
        new PIXI.BlurFilter(),
      ];
      app.stage.addChild(backgroundMask);
      const sandNoise = new PIXI.NoiseFilter(0.4, 6);
      const sand = new PIXI.Graphics();
      sand.beginFill(0xc2b280);
      sand.drawRect(
        0,
        app.renderer.height - 80,
        app.renderer.width,
        app.renderer.height
      );
      sand.filters = [sandNoise];

      app.stage.addChild(sand);

      // Rock Pile
      const rocks = new PIXI.Container();
      const rock1 = PIXI.Sprite.from("img/rock.png");
      const rock2 = PIXI.Sprite.from("img/rock.png");
      const rock3 = PIXI.Sprite.from("img/rock.png");
      rock1.anchor.set(0.5);
      rock2.anchor.set(0.5);
      rock3.anchor.set(0.5);
      rock1.scale.set(0.5);
      rock1.tint = 0xaaaaaa;
      rock2.scale.set(0.4);
      rock2.tint = 0xcccccc;
      rock3.scale.set(0.3);
      rock3.tint = 0xeeeeee;

      rock2.x = -60;
      rock2.y = 26;

      rock3.x = 88;
      rock3.y = 35;

      rocks.x = 120;
      rocks.y = 422;

      // Our actors, in order of appearance
      const fish1 = new Fish("img/fish.png", 0.2, 320, 100, 250, 10);
      const fish2 = new CamoFish("img/fish2.png", 0.15, 320, 200, 250, 10);
      const fish3 = new DraggableFish(0.5);
      fish3.x = 50;
      fish3.y = 300;
      const school = new School(300, 300, 150, 0.1);
      const bubbler = new Bubbler();
      const plant = new Plant("img/plant.png", 0.7, 620, 450);

      const button = new Button("Change Goldfish Color", 100, 50);

      button.x = 50;
      button.y = 380;
      button.buttonLabel.scale.set(0.8);

      button.on("pointertap", (e) => {
        const color = Math.random() * 0xffffff;
        fish1.sprite.tint = color;
      });

      const slider = new Slider();

      slider.x = 300;
      slider.y = 450;

      fish1.slider = slider;

      rocks.addChild(rock1, rock2, rock3);
      app.stage.addChild(rocks);
      app.stage.addChild(fish3);
      app.stage.addChild(button);
      app.stage.addChild(slider);
      // let counter = 0;
      function loop() {
        // counter++;
        bubbler.tick();
        fish1.tick();
        fish2.tick();
        school.tick();
        plant.tick();
        fish3.tick();

        requestAnimationFrame(loop);
      }
      loop();
    </script>
  </body>
</html>
