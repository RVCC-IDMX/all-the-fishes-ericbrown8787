<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Animations</title>

    <script src="https://pixijs.download/release/pixi.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js
"></script>
  </head>
  <body>
    <script>
      // The app
      const app = new PIXI.Application({
        width: 1024,
        height: 768,
        backgroundColor: 0x000000,
      });

      // class Counter {
      //   // For generating unique counters so all of the objects start at different spots on the sine wave
      //   constructor() {
      //     this.value = Math.floor(Math.random() * 1000);
      //   }
      // }

      document.body.appendChild(app.view);

      // Animator
      const Animate = {};

      Animate.to = function (obj, end) {
        // Make a promise
        return new Promise((resolve, reject) => {
          // Initial state parameters
          const start = {
            x: obj.x,
            y: obj.y,
            scaleX: obj.scale.x,
            scaleY: obj.scale.y,
            alpha: obj.alpha,
            rotation: (obj.rotation * 180) / Math.PI,
            tint: obj.tint,
          };

          // Set defaults
          if (end.duration == undefined) end.duration = 100;
          if (end.easing == undefined) end.easing = Animate.linear;

          // We need to know when we start
          const startTime = Date.now();

          //This is the object's animation loop
          function loop() {
            // Calculate delta
            const ticker = Date.now() - startTime;
            const delta = ticker / end.duration;
            const ease = end.easing(delta);

            // Are we done? Snap to end
            if (delta >= 1 || end.duration === 0) {
              if (end.x != undefined) {
                obj.x = end.x;
              }
              if (end.y != undefined) {
                obj.y = end.y;
              }
              if (end.scaleX != undefined) {
                obj.scale.x = end.scaleX;
              }

              if (end.scaleY != undefined) {
                obj.scale.y = end.scaleY;
              }

              resolve();
              return;
            }

            function lerp(a, b, n) {
              return (1 - n) * a + n * b;
            }

            // Lerp alpha
            if (end.alpha != undefined) {
              obj.alpha = lerp(start.alpha, end.alpha, ease);
            }
            // lerp coordinates
            if (end.x != undefined) {
              obj.x = lerp(start.x, end.x, ease);
            }
            if (end.y != undefined) {
              obj.y = lerp(start.y, end.y, ease);
            }

            // Lerp scale
            if (end.scaleX != undefined) {
              obj.scale.x = lerp(start.scaleX, end.scaleX, ease);
            }
            if (end.scaleY != undefined) {
              obj.scale.y = lerp(start.scaleY, end.scaleY, ease);
            }

            // Lerp rotation
            // this reminded me that 0 is falsy
            if (end.rotation != undefined) {
              obj.rotation = lerp(
                // Converting these to degrees because it's easier to visualize
                (start.rotation * Math.PI) / 180,
                (end.rotation * Math.PI) / 180,
                ease
              );
            }

            // Lerp tint
            if (end.tint != undefined) {
              // Maybe we'll come back to this
              // const r = Math.round(
              //   lerp(
              //     Number(`${start.tint}`.toString(16).slice(0, 2)),
              //     Number(`${end.tint}`.toString(16).slice(0, 2)),
              //     ease
              //   )
              // ).toString(16);
              // console.log(r);
              // const g = Math.round(
              //   lerp(
              //     Number(`${start.tint}`.toString(16).slice(2, 4)),
              //     Number(`${end.tint}`.toString(16).slice(2, 4)),
              //     ease
              //   )
              // ).toString(16);
              // console.log(g);
              // const b = Math.round(
              //   lerp(
              //     Number(`${start.tint}`.toString(16).slice(4, 6)),
              //     Number(`${end.tint}`.toString(16).slice(4, 6)),
              //     ease
              //   )
              // ).toString(16);
              // console.log(b);
              // obj.tint = Number(
              //   `0x${r.padStart(2, '0')}${g.padStart(2, '0')}${b.padStart(
              //     2,
              //     '0'
              //   )}`
              // );
              obj.tint = lerp(start.tint, end.tint, ease);
            }

            // Loop
            // Saving the animationID for later
            obj.animationID = requestAnimationFrame(loop);
          }
          cancelAnimationFrame(obj.animationID);
          loop();
        });
      };

      Animate.stop = function (obj) {
        cancelAnimationFrame(obj.animationID);
      };

      Animate.linear = (x) => x;

      // Quadratic Easing
      Animate.easeIn = (x) => x * x;

      Animate.easeOut = (x) => 1 - (1 - x) * (1 - x);

      Animate.easeInOut = (x) => {
        if (x < 0.5) return 2 * x * x;
        return 1 - Math.pow(-2 * x + 2, 2) / 2;
      };

      // Pause
      Animate.pause = (ms) => {
        return new Promise((resolve, reject) => setTimeout(resolve, ms));
      };

      // Instantiate the fish
      const fish1 = PIXI.Sprite.from("img/fish1.png");

      const fish2 = PIXI.Sprite.from("img/fish2.png");
      const fish3 = PIXI.Sprite.from("img/fish3.png");
      const school = new PIXI.Container();

      fish1.anchor.set(0.5);
      fish1.scale.set(0.1);
      fish1.startOrientation = fish1.scale.x;
      fish1.interactive = true;
      //storing initial positions in properties for later reference

      fish1.x = 900;
      fish1.y = 200;
      fish1.startX = fish1.x;
      fish1.startY = fish1.y;

      fish3.anchor.set(0.5);
      fish3.scale.set(0.2);
      fish3.scale.x *= -1;
      fish3.startOrientation = fish3.scale.x;
      fish3.interactive = true;

      fish3.x = 200;
      fish3.y = 600;
      fish3.startX = fish3.x;
      fish3.startY = fish3.y;

      // Add a fully transparent "glass" layer behind the fish to tap on and attract fish3
      const glass = new PIXI.Graphics();
      glass.interactive = true;
      glass.beginFill(0x000000);
      glass.alpha = 0;

      glass.drawRect(0, 0, app.renderer.width, app.renderer.height);

      // Add some abstract sand
      const sand = new PIXI.Graphics();
      const sandNoise = new PIXI.NoiseFilter(0.4, 6);
      sand.beginFill(0xaa98a9);
      sand.drawRect(
        0,
        app.renderer.height - 80,
        app.renderer.width,
        app.renderer.height
      );
      sand.filters = [sandNoise];

      // Add rocks
      const rocks = new PIXI.Container();
      const rock1 = PIXI.Sprite.from("img/rock.png");
      const rock2 = PIXI.Sprite.from("img/rock.png");
      const rock3 = PIXI.Sprite.from("img/rock.png");
      rocks.addChild(rock1);
      rocks.addChild(rock2);
      rocks.addChild(rock3);
      rock1.anchor.set(0.5);
      rock2.anchor.set(0.5);
      rock3.anchor.set(0.5);
      rock1.scale.set(0.5);
      rock1.tint = 0xaaaaaa;
      rock2.scale.set(0.4);
      rock2.tint = 0xcccccc;
      rock3.scale.set(0.3);
      rock3.tint = 0xeeeeee;

      rock2.x = -60;
      rock2.y = 26;

      rock3.x = 88;
      rock3.y = 35;

      rocks.x = 130;
      rocks.y = 700;
      rocks.scale.set(1.3);

      //Add all objects to the stage

      app.stage.addChild(sand);

      app.stage.addChild(fish3);
      app.stage.addChild(rocks);
      app.stage.addChild(glass);
      app.stage.addChild(fish1);

      // Define fish behaviors

      async function fish1Behavior() {
        await Animate.to(fish1, {
          y: fish1.y + 50,
          duration: 1000,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish1, {
          y: fish1.y - 50,
          duration: 1000,
          easing: Animate.easeIn,
        });

        requestAnimationFrame(fish1Behavior);
      }

      async function fish3Behavior() {
        await Animate.to(fish3, {
          x: fish3.x + 600,
          duration: 1500,
          easing: Animate.easeOut,
        });
        await Animate.to(fish3, {
          scaleX: fish3.scale.x * -1,
          duration: 250,
          easing: Animate.easeIn,
        });
        await Animate.to(fish3, {
          x: fish3.x - 600,
          duration: 1500,
          easing: Animate.easeOut,
        });
        await Animate.to(fish3, {
          scaleX: fish3.scale.x * -1,
          duration: 250,
          easing: Animate.easeIn,
        });

        requestAnimationFrame(fish3Behavior);
      }

      // Interactive events in order of precedence
      glass.on("pointertap", async (event) => {
        const origX = fish3.x;
        const origY = fish3.y;
        const tapX = event.screen.x;
        const tapY = event.screen.y;
        const currentFish3Orientation = Math.abs(fish3.scale.x) / fish3.scale.x;
        glass.interactive = false;
        //Handling fish orientation
        if (tapX > origX) {
          await Animate.to(fish3, {
            scaleX: Math.abs(fish3.scale.x) * -1,
            duration: 250,
            easing: Animate.easeOut,
          });
        } else if (tapX < origX) {
          await Animate.to(fish3, {
            scaleX: Math.abs(fish3.scale.x),
            duration: 250,
            easing: Animate.easeInOut,
          });
        }

        //Swim to where user tapped glass
        await Animate.to(fish3, {
          x: tapX,
          y: tapY,
          duration: 2000,
          easing: Animate.easeOut,
        });
        await Animate.pause(500);

        // Do a little angry dance
        await Animate.to(fish3, {
          tint: 0xff0000,
          rotation: 45,
          duration: 250,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish3, {
          tint: 0xffffff,
          rotation: -45,
          duration: 250,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish3, {
          tint: 0xff0000,
          rotation: 45,
          duration: 250,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish3, {
          tint: 0xffffff,
          rotation: -45,
          duration: 250,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish3, {
          tint: 0xffffff,
          rotation: 0,
          duration: 250,
          easing: Animate.easeInOut,
        });

        //Handling fish orientation
        if (tapX > origX) {
          await Animate.to(fish3, {
            scaleX: Math.abs(fish3.scale.x),
            duration: 250,
            easing: Animate.easeInOut,
          });
        } else if (tapX < origX) {
          await Animate.to(fish3, {
            scaleX: Math.abs(fish3.scale.x) * -1,
            duration: 250,
            easing: Animate.easeInOut,
          });
        }

        //Swim back
        await Animate.to(fish3, {
          x: fish3.startX,
          y: fish3.startY,
          duration: 2000,
          easing: Animate.easeInOut,
        });

        //Handling fish orientation
        await Animate.to(fish3, {
          scaleX: fish3.startOrientation,
          duration: 250,
          easing: Animate.easeInOut,
        });
        glass.interactive = true;
        requestAnimationFrame(fish3Behavior);
      });
      fish1.on("pointertap", async (event) => {
        // const origX = fish1.x;
        // const origY = fish1.y;
        fish1.interactive = false;
        await Animate.to(fish1, {
          y: 50,
          x: 350,
          duration: 2000,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish1, {
          scaleX: fish1.scale.x * -1,
          duration: 250,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish1, {
          rotation: 980,
          tint: 0x00ffff,
          duration: 1500,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish1, {
          rotation: 0,
          tint: 0xffffff,
          duration: 1500,
          easing: Animate.easeInOut,
        });
        fish1.tint = 0xffffff;
        await Animate.to(fish1, {
          y: fish1.startY,
          x: fish1.startX,
          duration: 2000,
          easing: Animate.easeInOut,
        });
        await Animate.to(fish1, {
          scaleX: fish1.scale.x * -1,
          duration: 250,
          easing: Animate.easeInOut,
        });
        fish1.interactive = true;
        fish1Behavior();
      });

      window.addEventListener("load", fish1Behavior);
      window.addEventListener("load", fish3Behavior);
      // window.addEventListener("load", schoolBehavior);

      // Check easings.net for more easing functions
    </script>
  </body>
</html>
